#!/usr/bin/env ruby
# :title: PlanR::Plugins::Picky Document search
=begin rdoc
=Picky Plugins
(c) Copyright 2016 Thoughtgang <http://www.thoughtgang.org>
=end

require 'tg/plugin'
require 'plan-r/plugins/shared/picky/index'


module PlanR
  module Plugins
    module Search

      class PickyDocumentIndex
        extend TG::Plugin
        name 'Document Index'
        author 'dev@thoughtgang.org'
        version '0.5'
        description 'Document index based on Picky gem'
        help 'Search index for documents.
See http://pickyrb.com/ .'

        INDEX_BASE_NAME = 'doc'
        INDEX_PROP_NAME = :picky_doc_index_name
        include PlanR::Plugins::Picky

        def load_index(repo)
          idx_name = open_index(repo)

          # define index
          idx = DocIndex.new(idx_name, repo, index_base_name) do
            key_format :to_s
            category :tags, tokenize: false
            category :keywords, tokenize: false,
                                weight: ::Picky::Weights::Logarithmic.new(+2)
            category :name
            category :author
            category :license
            category :language
            category :mime_type
            category :file_type
            category :path, weight: ::Picky::Weights::Logarithmic.new(-1)
            category :title, weight: ::Picky::Weights::Logarithmic.new(+1)
            category :description, weight: ::Picky::Weights::Logarithmic.new(+1)
            # These are auto-generated by summarize gem
            category :summary, weight: ::Picky::Weights::Logarithmic.new(-1)
            category :topics, tokenize: false,
                              weight: ::Picky::Weights::Logarithmic.new(-1)
            category :abstract, weight: ::Picky::Weights::Logarithmic.new(+1)
            # This is already tokenized by Plan-R plugins
            category :contents, tokenize: false
            result_identifier 'docs'
          end

          read_index(idx)
        end
        spec :repo_open, :load_index, 50

        def save_index(repo)
          idx = fetch_index(repo)
          return nil if (! idx)
          idx.dump
        end
        spec :repo_close, :save_index, 50

        #def tokenize_document(parsed_doc, h)
        #end
        #spec :tokenize_doc, :tokenize_document, 50

        #def analyze_document(parsed_doc)
        #end
        #spec :analyze_doc, :analyze_document, 50

        def index_document(repo, doc, tok_h)
          # FIXME: default to Picky tokenizer
          toks = tok_h['Plaintext Tokenizer']
          # otherwise, use longest array of tokens
          toks ||= tok_h.values.sort { |a,b| a.length <=> b.length }.last

          pdoc = PickyDocument.new(doc, tok_h)
          idx = fetch_index(doc.repo)
          return false if (! idx)
          len = pdoc.contents.length 
          if len > 50000
            # FIXME: log
            $stderr.puts "[PICKY] WARNING: Indexing #{len} tokens"
          end
          idx.add(pdoc)
          true
        end
        spec :index_doc, :index_document, 50

        def copy_document(repo, from_doc, to_doc)
          idx = fetch_index(doc.repo)
          return false if (! idx)
          return true if (! idx.indexed? from_doc)
          idx.add to_doc
        end
        spec :repo_clone_doc, :copy_document, 50

        def remove_document(doc)
          idx = fetch_index(doc.repo)
          return nil if (! idx)
          return true if (! idx.indexed? doc)
          idx.remove doc.id
        end
        spec :repo_remove_doc, :remove_document, 50

        def query(repo, q)
          idx = fetch_index(repo)
          return [] if (! idx)
          begin
            s = ::Picky::Search.new(idx) { 
              # FIXME: more complex options
              ignore_unassigned_tokens 
            }
            results = s.search(q.terms.join(' '))
            arr = []
            results.each do |x|
               res = x.to_result 
               next if (! res)  # FIXME: better error checking
               #ident = res[0] # index identifier
               score = res[1]
               #count = res[2] # number of hits
               #combs = res[3] # combinations.to_result

               res[4].each do |id|
                 ctype, path = id.split(':', 2)
                 r = Query::Result.new(path, ctype.to_sym, score)
                 # FIXME:
                 # r.terms = { term -> { :field -> :pos } }
                 arr << r
               end
            end

            arr

          rescue Exception => e
            puts e.message
            puts e.backtrace[0,4].join("\n")
            []
          end
        end
        spec :query_index, :query, 50

        def related_documents(doc)
          # FIXME: TODO
        end
        spec :related_docs, :related_documents, 50

        # TODO: stats
        # QUERY:
        # [default set of categories to boost]
        # boost importance of field/category 'title'
        # boost [:title] => +1
        # boost [:first, :last] => +3  # combo boosted if in this order
        # ignore :title # ignore this category
        # ignore_unassigned_tokens # always use this unless 'strict'

        # ----------------------------------------------------------------------
        # INDEX STATS

        CATEGORIES = [ :tags, :keywords, :name, :author, :license, :language,
                       :mime_type, :file_type, :path, :title, :description,
                       :summary, :topics, :abstract, :contents ]
        def list_keywords(repo, h)
          idx = fetch_index(repo)
          return [] if (! idx)
          toks = {}
          # FIXME: make sure this is correct
          CATEGORIES.each do |tag|
            idx.facets(tag).each { |k,v| toks[k] ||= 0; toks[k] += v }
          end
          h[:stats] ? toks : toks.keys
        end
        spec :index_keywords, :list_keywords, 50

        def list_docs(repo, h)
          idx = fetch_index(repo)
          return [] if (! idx)
          idx.indexed_ids.map { |id| id.split(':', 2) }
        end
        spec :index_docs, :list_docs, 50

        def generate_stats(repo, h)
          idx = fetch_index(repo)
          return nil if (! idx)
          # FIXME : implement
          #idx.exact.inverted
          #idx.exact.weights
          #idx.partial.inverted
          #idx.partial.weights
          {}
        end
        spec :index_stats, :generate_stats, 50

        def generate_log(repo, h)
          idx = fetch_index(repo)
          return nil if (! idx)

          # FIXME : implement
          ''
        end
        spec :index_log, :generate_log, 50

        def generate_report(repo, h)
          idx = fetch_index(repo)
          return nil if (! idx)
          idx.to_tree_s
        end
        spec :index_report, :generate_report, 50

        def query_to_hash(repo, q)
          idx = fetch_index(repo)
          return nil if (! idx)
          # FIXME: implement
          {}
        end
        spec :query_parse, :query_to_hash, 50

      end

    end
  end
end
